use frost::{
    keys::dkg::{
        part1, part2, part3,
        round1::{Package, SecretPackage},
        round2,
    },
    Error, Identifier,
};
#[cfg(not(feature = "redpallas"))]
use frost_ed25519 as frost;
use rand::thread_rng;
#[cfg(feature = "redpallas")]
use reddsa::frost::redpallas as frost;
use std::{
    collections::{BTreeMap, HashMap},
    sync::Arc,
};
use uniffi;

use crate::{FrostError, FrostKeyPackage, FrostPublicKeyPackage, ParticipantIdentifier};

#[derive(uniffi::Record)]
pub struct DKGPart3Result {
    pub public_key_package: FrostPublicKeyPackage,
    pub key_package: FrostKeyPackage,
}

#[derive(uniffi::Object, Clone)]
pub struct DKGPart2Result {
    pub secret: DKGRound2SecretPackage,
    pub packages: Vec<DKGRound2Package>,
}

#[derive(uniffi::Record, Clone)]
pub struct DKGRound2Package {
    // to whom this should be send to
    pub identifier: ParticipantIdentifier,
    // wrapped data 
    pub data: Vec<u8>,
}

impl DKGRound2Package {
    fn from_package(
        identifier: ParticipantIdentifier,
        package: round2::Package,
    ) -> Result<DKGRound2Package, Error> {
        Ok(DKGRound2Package {
            identifier: identifier,
            data: package.serialize()?,
        })
    }

    fn into_package(&self) -> Result<round2::Package, Error> {
        Ok(round2::Package::deserialize(&self.data)?)
    }
}

#[derive(uniffi::Object)]
pub struct DKGPart1Result {
    pub secret: DKGRound1SecretPackage,
    pub package: DKGRound1Package,
}

#[derive(uniffi::Object, Clone)]
pub struct DKGRound2SecretPackage {
    data: round2::SecretPackage,
}

#[derive(uniffi::Object, Clone)]
pub struct DKGRound1SecretPackage {
    data: SecretPackage,
}

impl DKGRound1SecretPackage {
    fn from_secret_package(secret_package: SecretPackage) -> DKGRound1SecretPackage {
        DKGRound1SecretPackage {
            data: secret_package,
        }
    }
}

#[derive(uniffi::Record, Clone)]
pub struct DKGRound1Package {
    pub identifier: ParticipantIdentifier,
    pub data: Vec<u8>,
}

impl DKGRound1Package {
    fn into_package(&self) -> Result<Package, Error> {
        Ok(Package::deserialize(&self.data)?)
    }

    fn from_package(
        identifier: ParticipantIdentifier,
        package: Package,
    ) -> Result<DKGRound1Package, Error> {
        Ok(DKGRound1Package {
            identifier: identifier,
            data: package.serialize()?,
        })
    }
}

#[uniffi::export]
pub fn part_1(
    participant_identifier: ParticipantIdentifier,
    max_signers: u16,
    min_signers: u16,
) -> Result<Arc<DKGPart1Result>, FrostError> {
    let identifier = participant_identifier
        .into_identifier()
        .map_err(|_| FrostError::UnknownIdentifier)?;
    let rng = thread_rng();
    let part_one = part1(identifier, max_signers, min_signers, rng)
        .map_err(|_| FrostError::InvalidConfiguration)?;

    let secret = DKGRound1SecretPackage::from_secret_package(part_one.0);
    let package = DKGRound1Package::from_package(participant_identifier, part_one.1)
        .map_err(|_| FrostError::DeserializationError)?;

    Ok(Arc::new(DKGPart1Result {
        secret: secret,
        package: package,
    }))
}
/// DKG Part 2
/// receives a SecretPackage from round one generated by the same
/// participant and kept in-memory (and secretly) until now.
/// It also receives the round 1 packages corresponding to all the 
/// other participants **except** itself.
/// 
/// Example: if P1, P2 and P3 are doing DKG, then when P1 runs part_2
/// this will receive a secret generated by P1 in part_1 and the
/// round 1 packages from P2 and P3. Everyone else has to do the same.
/// 
/// For part_3 the P1 will send the round 2 packages generated here to
/// the other participants P2 and P3 and should receive packages from
/// P2 and P3.
#[uniffi::export]
pub fn part_2(
    secret_package: Arc<DKGRound1SecretPackage>,
    round1_packages: HashMap<ParticipantIdentifier, DKGRound1Package>,
) -> Result<Arc<DKGPart2Result>, FrostError> {
    let secret_package = secret_package.data.clone();

    let mut packages: BTreeMap<Identifier, Package> = BTreeMap::new();

    for (id, pkg) in round1_packages.into_iter() {
        let package = pkg
            .into_package()
            .map_err(|_| FrostError::DeserializationError)?;
        let identifier = id
            .into_identifier()
            .map_err(|_| FrostError::DeserializationError)?;
        packages.insert(identifier, package);
    }

    let (secret, round2_packages) = part2(secret_package, &packages).map_err(|e| match e {
        Error::IncorrectNumberOfCommitments => FrostError::DKGPart2IncorrectNumberOfCommitments,
        Error::IncorrectNumberOfPackages => FrostError::DKGPart2IncorrectNumberOfPackages,
        _ => FrostError::UnexpectedError,
    })?;

    let mut packages: Vec<DKGRound2Package> = Vec::new();

    let secret = DKGRound2SecretPackage { data: secret };

    for pkg in round2_packages.into_iter() {
        let identifier = ParticipantIdentifier::from_identifier(pkg.0)
            .map_err(|_| FrostError::SerializationError)?;

        let package = DKGRound2Package::from_package(identifier.clone(), pkg.1)
            .map_err(|_| FrostError::SerializationError)?;

        packages.push(package);
    }

    Ok(Arc::new(DKGPart2Result {
        secret: secret,
        packages: packages,
    }))
}

#[uniffi::export]
pub fn part_3(
    secret_package: Arc<DKGRound2SecretPackage>,
    round1_packages: HashMap<ParticipantIdentifier, DKGRound1Package>,
    round2_packages: HashMap<ParticipantIdentifier, DKGRound2Package>,
) -> Result<DKGPart3Result, FrostError> {
    let secret_package = secret_package.data.clone();

    let mut round1_pkg: BTreeMap<Identifier, Package> = BTreeMap::new();

    for (id, pkg) in round1_packages.into_iter() {
        let package = pkg
            .into_package()
            .map_err(|_| FrostError::DeserializationError)?;
        let identifier = id
            .into_identifier()
            .map_err(|_| FrostError::DeserializationError)?;
        round1_pkg.insert(identifier, package);
    }

    let mut round2_pkg: BTreeMap<Identifier, round2::Package> = BTreeMap::new();

    for (id, pkg) in round2_packages.into_iter() {
        let package = pkg
            .into_package()
            .map_err(|_| FrostError::DeserializationError)?;
        let identifier = id
            .into_identifier()
            .map_err(|_| FrostError::DeserializationError)?;
        round2_pkg.insert(identifier, package);
    }

    let (key_packages, pubkey) = part3(&secret_package, &round1_pkg, &round2_pkg)
        .map_err(|e| {
            match e {
                Error::IncorrectNumberOfPackages => FrostError::DKGPart3IncorrectNumberOfPackages,
                Error::IncorrectPackage => FrostError::DKGPart3IncorrectRound1Packages,
                Error::PackageNotFound => FrostError::DKGPart3PackageSendersMismatch,
                _ => FrostError::UnexpectedError
            }
        })?;

    Ok(DKGPart3Result {
        public_key_package: FrostPublicKeyPackage::from_public_key_package(pubkey)
            .map_err(|_| FrostError::SerializationError)?,
        key_package: FrostKeyPackage::from_key_package(&key_packages)
            .map_err(|_| FrostError::SerializationError)?,
    })
}
